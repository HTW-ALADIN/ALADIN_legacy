{"version":3,"sources":["webpack:///./src/views/Replay.vue?6b84","webpack:///./src/views/Replay.vue","webpack:///./src/components/ReplayOverlay.vue","webpack:///./src/components/ReplayOverlay.vue?5368","webpack:///./src/components/ReplayOverlay.vue?a49f","webpack:///./src/views/Replay.vue?a4ff","webpack:///./src/views/Replay.vue?e7b1","webpack:///./src/components/ReplayOverlay.vue?cf0b"],"names":["class","name","isDecisionNode","storeObject","replayStore","isLoaded","key","currentNode","taskStore","src","fadeControlsIn","fadeControlsOut","jumpHandler","replayGraph","steps","marker","i","style","placeMarker","timestamp","callback","startStopHandler","label","enterTask","props","Object","components","Button","setup","start","duration","router","store","getProperty","setProperty","replay","barSize","window","innerWidth","barOffset","calcDuration","times","Date","getTime","end","values","forEach","events","length","firstEvent","lastEvent","segmentMouse","mouse","previous","segment","segments","reduce","event","push","current","mouseSegments","newReplayGraph","path","value","progressInterval","fade","difference","percentage","position","left","applyMouse","jump","cursor","document","querySelector","movements","filter","x","y","transform","baseCoordinates","applyPanning","panning","relativeX","Math","abs","relativeY","panzoom","pan","relative","animate","getPan","applyZooming","zooming","zoomEvent","scale","zoomToPoint","clientX","clientY","applyEvents","dispatch","convertPxToTimestamp","px","progressBar","currentTarget","progress","firstChild","clickPosition","pageX","width","isPlaying","playButton","clearInterval","innerHTML","increment","pxPerIncrement","setInterval","currentWidth","offsetWidth","newWidth","task","properties","property","propertyValue","timeCorrectedReplay","entries","eventType","eventValues","timeCorrectedValues","map","offset","params","clearTimeout","controls","target","opacity","setTimeout","render","__scopeId","Canvas","DecisionNode","ReplayOverlay","route","id","edges"],"mappings":"wJAAA,W,0JCCOA,MAAM,Q,wOAAX,yBAQM,MARN,EAQM,CAPJ,yBAEa,iBAFDC,KAAK,aAAW,C,WAC1B,iBAAiE,CAA7C,EAAAC,gB,yBAApB,yBAAiE,G,MAA5BC,YAAa,EAAAC,a,0EAEpD,yBAEa,iBAFDH,KAAK,aAAW,C,WAC1B,iBAA2F,EAA5E,EAAAC,gBAAkB,EAAAG,U,yBAAjC,yBAA2F,GAA/CC,IAAK,EAAAC,YAAcJ,YAAa,EAAAC,a,0EAE9E,yBAAmE,GAAnDA,YAAa,EAAAA,YAAcI,UAAW,EAAAA,W,0LCPnDR,MAAM,iB,EACT,yBAAqD,OAAhDA,MAAM,aAAaS,IAAI,wB,WAGxB,yBAA4B,OAAvBT,MAAM,YAAU,S,GAGlBA,MAAM,mB,uIAPf,yBAYM,MAZN,EAYM,CAXJ,EACA,yBASM,OATDA,MAAM,SAAU,aAAU,8BAAE,EAAAU,gBAAA,EAAAA,eAAA,qBAAiB,aAAU,8BAAE,EAAAC,iBAAA,EAAAA,gBAAA,sB,CAC5D,yBAGM,OAHDX,MAAM,cAAe,QAAK,8BAAE,EAAAY,aAAA,EAAAA,YAAA,sB,CAC/B,G,2BACA,yBAAoI,2CAAlD,EAAAC,YAAYC,OAAK,SAA/BC,EAAQC,G,gCAA5E,yBAAoI,OAA9HhB,MAAK,kBAAagB,EAAb,WAA0BC,MAAO,EAAAC,YAAYF,GAA8CV,IAAKS,EAAOI,WAAW,IAAC,M,QAEhI,yBAGM,MAHN,EAGM,CAFJ,yBAA6E,GAArEnB,MAAM,aAAcoB,SAAU,EAAAC,iBAAmBC,MAAO,K,qBAChE,yBAAyE,GAAjEtB,MAAM,cAAeoB,SAAU,EAAAG,UAAYD,MAAO,M,2ICNnD,GACbrB,KAAM,gBACNuB,MAAO,CACLpB,YAAaqB,OACbjB,UAAWiB,QAEbC,WAAY,CAAEC,SAAA,MACdC,MAPa,SAOPJ,GACJ,IA2CIK,EAAOC,EA3CLC,EAAS,iBADN,EAGmCP,EAAMpB,YAA1C4B,EAHC,EAGDA,MAAOC,EAHN,EAGMA,YAAaC,EAHnB,EAGmBA,YACtBrB,EAAc,uBAAS,WAC3B,IAAMsB,EAASF,EAAY,cAC3B,OAAKE,GAAe,MAIhBC,EAA8B,GAApBC,OAAOC,WAAmB,IACpCC,EAAgC,KAApBF,OAAOC,WAEnBE,EAAe,SAAC3B,GACpB,IAAM4B,EAAQ,CAAEZ,OAAO,IAAIa,MAAOC,UAAWb,SAAU,EAAGc,IAAK,GAU/D,OATAnB,OAAOoB,OAAOhC,GAAaiC,SAAQ,SAACC,GAClC,GAAKA,EAAOC,OAAZ,CACA,IAAMC,EAAaF,EAAO,GAAG5B,UACvB+B,EAAYH,EAAOA,EAAOC,OAAS,GAAG7B,UACxC8B,EAAaR,EAAMZ,QAAOY,EAAMZ,MAAQoB,GACxCC,EAAYT,EAAMG,MAAKH,EAAMG,IAAMM,OAGzCT,EAAMX,SAAWW,EAAMG,IAAMH,EAAMZ,MAC5BY,GAGHU,EAAe,SAACtC,EAAagB,GAAS,IAClCuB,EAAUvC,EAAVuC,MACJC,EAAWxB,EACXyB,EAAU,GACRC,EAAWH,EAAMI,QAAO,SAACD,EAAUE,GAAS,IACxCtC,EAAcsC,EAAdtC,UAQR,OAPIA,EAAYkC,GAAY,GAC1BC,EAAQI,KAAKD,IAEbF,EAASF,GAAYC,EACrBA,EAAU,CAACG,IAEbJ,GAAY,GACLE,IACN,IACH,OAAOA,GAGLI,EAAU9B,EACV+B,EAAgB,GACpB,mBAAM/C,GAAa,SAACgD,GAClB3B,EAAY,CAAE4B,KAAM,cAAeC,MAAOF,EAAe/C,MAAM,GAAGiD,QAD9B,MAGRvB,EAAaqB,GAAtChC,EAHiC,EAGjCA,MAAOC,EAH0B,EAG1BA,SAH0B,EAGhBc,IACpBgB,EAAgBT,EAAaU,EAAgBhC,GAC7C8B,EAAU9B,KAGZ,IAqFImC,EAiFAC,EAtKE/C,EAAc,SAACF,GACnB,IAAMG,EAAYN,EAAYkD,MAAMjD,MAAME,GAAGG,UACvC+C,EAAa/C,EAAYU,EACzBsC,EAAaD,EAAapC,EAC1BsC,EAAWD,EAAa/B,EAC9B,MAAO,CAAEiC,KAAM,GAAF,OAAKD,EAAL,QAGTE,EAAa,SAACnD,GAA4C,IAAzBoD,EAAyB,wDACxDC,EAAsBC,SAASC,cAAc,eAC3CtB,EAAUvC,EAAYkD,MAAtBX,MACR,GAAImB,EAAJ,CACE,IAAMI,EAAYvB,EAAMwB,QAAO,SAACnB,GAAD,OAAWA,EAAMtC,UAAYA,KAC5D,GAAIwD,EAAU3B,OAAQ,OACH2B,EAAUA,EAAU3B,OAAS,GAAtC6B,EADY,EACZA,EAAGC,EADS,EACTA,EACXN,EAAOvD,MAAM8D,UAAb,oBAAsCF,EAAtC,eAA8CC,EAA9C,aAIA3D,KAAayC,GACfA,EAAczC,GAAW2B,SAAQ,SAACW,GAAS,IACjCoB,EAASpB,EAAToB,EAAGC,EAAMrB,EAANqB,EACXN,EAAOvD,MAAM8D,UAAb,oBAAsCF,EAAtC,eAA8CC,EAA9C,WAMFE,EAAkB,CAAEH,EAAG,IAAMC,EAAG,KAC9BG,EAAe,SAAC9D,GACpB,GAAI6D,EAAiB,OACFA,EAATH,EADW,EACXA,EAAGC,EADQ,EACRA,EAEL/B,EAASlC,EAAYkD,MAAMmB,QAAQN,QAAO,SAACnB,GAAD,OAAWA,EAAMtC,UAAYA,GAAasC,EAAMtC,UAAYwC,KAE5GZ,EAAOD,SAAQ,SAACW,GACd,IAAM0B,EAAYC,KAAKC,IAAIR,GAAKO,KAAKC,IAAI5B,EAAMoB,GACzCS,EAAYF,KAAKC,IAAIP,GAAKM,KAAKC,IAAI5B,EAAMqB,GAC/CzC,OAAOkD,QAAQC,IAAIL,EAAWG,EAAW,CAAEG,UAAU,EAAMC,SAAS,IACpEV,EAAkB3C,OAAOkD,QAAQI,cAKjCC,EAAe,SAACzE,GACpB,IAAM4B,EAASlC,EAAYkD,MAAM8B,QAAQjB,QAAO,SAACnB,GAAD,OAAWA,EAAMtC,UAAYA,GAAasC,EAAMtC,UAAYwC,KAC5GZ,EAAOD,SAAQ,SAACgD,GAAa,IACrBC,EAAgBD,EAAhBC,MAAOlB,EAASiB,EAATjB,EAAGC,EAAMgB,EAANhB,EAChBzC,OAAOkD,QAAQS,YAAYD,EAAO,CAAEE,QAASpB,EAAGqB,QAASpB,GAAK,CAAEY,SAAS,QAIvES,EAAc,SAAChF,GACnB,IAAI4B,EAAS,GACT5B,EAAYwC,GACd3B,EAAMoE,SAAS,cACfrD,EAASlC,EAAYkD,MAAMjD,MAAM8D,QAAO,SAACnB,GAAD,OAAWA,EAAMtC,UAAYA,MAErE4B,EAASlC,EAAYkD,MAAMjD,MAAM8D,QAAO,SAACnB,GAAD,OAAWA,EAAMtC,UAAYA,GAAasC,EAAMtC,UAAYwC,KAEtGZ,EAAOD,SAAQ,SAACW,GAAS,IACfK,EAAgBL,EAAhBK,KAAMC,EAAUN,EAAVM,MACd7B,EAAY,CAAE4B,OAAMC,cAIlBsC,EAAuB,SAACC,GAC5B,IAAMnF,EAAamF,EAAKlE,EAAWN,EAAWD,EAC9C,OAAOV,GAGHP,EAAc,SAAC6C,GACnB,IAAM8C,EAAc9C,EAAM+C,cACpBC,EAAWF,EAAYG,WACvBC,EAAgBlD,EAAMmD,MAAQrE,EACpCkE,EAASxF,MAAM4F,MAAf,UAA0BF,EAA1B,MACA,IAAMxF,EAAYkF,EAAqBM,GACvChD,EAAUxC,EACVyC,EAAgBT,EAAatC,EAAYkD,MAAO5C,GAChDgF,EAAYhF,GACZmD,EAAWnD,GAAW,GACtB8D,EAAa9D,GACbyE,EAAazE,IAIX2F,GAAY,EACVzF,EAAmB,SAACoC,GACxB,IAAMsD,EAAatD,EAAM+C,cACzB,GAAIM,EAIF,OAHAE,cAAchD,GACd8C,GAAaA,OACbC,EAAWE,UAAY,WAGzBF,EAAWE,UAAY,oBACvBH,GAAaA,EACb,IAAMI,EAAY,GACd/F,EAAYwC,EAEVwD,EAAkBD,EAAY9E,EAAWN,EACzC2E,EAAwBhC,SAASC,cAAc,aAErDV,EAAmBoD,aAAY,WAC7B,IAAMC,EAAeZ,EAASa,YACxBC,EAAWF,EAAeF,EAC5BI,EAAWnF,IACb4E,cAAchD,GACd8C,GAAaA,EACbC,EAAWE,UAAY,WAEzBR,EAASxF,MAAM4F,MAAf,UAA0BU,EAA1B,MACApG,GAAa+F,EACbf,EAAYhF,GACZmD,EAAWnD,GACX8D,EAAa9D,GAEbwC,EAAUxC,GAEL6D,GAAmB3C,OAAOkD,UAC7BP,EAAkB3C,OAAOkD,QAAQI,YAElCuB,IAGC3F,EAAY,WAChB,IAAMiG,EAAOvF,EAAY,eACnBwF,EAAa,CACjB,cACA,aACA,cACA,eACA,WACA,WACA,QACA,QACA,WACA,cAGFA,EAAW3E,SAAQ,SAAC4E,GAClB,IAAIC,EAAgB1F,EAAYyF,GAChC,GAAiB,eAAbA,EAA2B,CAC7B,IAAME,EAAsBnG,OAAOoG,QAAQF,GAAenE,QACxD,SAACoE,EAAD,GAAwE,0BAAjDE,EAAiD,KAAtCC,EAAsC,KACtE,GAAkB,SAAdD,EAAsB,OAAOF,EACjC,IAAMI,EAAsBD,EAAYE,KAAI,SAACxE,GAC3C,IAAME,GAAU,IAAIjB,MAAOC,UACrBuF,EAASvE,EAAUF,EAAMtC,UAE/B,OADAsC,EAAMtC,UAAYwC,EAAUuE,EACrBzE,KAGT,OADAmE,EAAoBE,GAAaE,EAC1BJ,IAET,IAEFD,EAAgBC,EAElBpG,EAAMhB,UAAU0B,YAAY,CAAE4B,KAAM4D,EAAU3D,MAAO4D,IACrDnG,EAAMhB,UAAUwB,MAAMoE,SAAS,yBAGjCrE,EAAO2B,KAAK,CAAEzD,KAAM,OAAQkI,OAAQ,CAAEX,WAIlC9G,EAAiB,SAAC+C,GACtB2E,aAAanE,GACb,IAAMoE,EAAwB5E,EAAM6E,OACpCD,EAASpH,MAAMsH,QAAU,KAErB5H,EAAkB,SAAC8C,GACvB,IAAM4E,EAAwB5E,EAAM6E,OACpCrE,EAAOuE,YAAW,WAChBH,EAASpH,MAAMsH,QAAU,QACxB,MAGL,MAAO,CAAE1H,cAAaD,cAAaS,mBAAkBH,cAAaK,YAAWb,iBAAgBC,qB,UChPjG,EAAO8H,OAAS,EAChB,EAAOC,UAAY,kBAEJ,QCAA,GACbzI,KAAM,SACNyB,WAAY,CACViH,SAAA,KACAC,eAAA,KACAC,iBAEFjH,MAPa,WAQX,IAAMpB,EAAY,OAAOA,UACnBJ,EAAc,OAAOA,YACnB4B,EAAoC5B,EAApC4B,MAAOC,EAA6B7B,EAA7B6B,YAET6G,GAFsC1I,EAAhB8B,YAEd,kBACiB,kBAApB4G,EAAMX,OAAOY,IACtB/G,EAAMoE,SAAS,mBAAoB,CAAE2C,GAAID,EAAMX,OAAOY,KAGxD,IAAMxI,EAAc,uBAAS,kBAAM0B,EAAY,kBACzC/B,EAAiB,uBAAS,WAC9B,IAAM8I,EAAQ/G,EAAY,UAAD,OAAW1B,EAAYwD,QAChD,QAAIiF,GAAcA,EAAMhG,OAAS,KAI7B3C,EAAW,uBAAS,kBAAqC,OAA/B4B,EAAY,kBAE5C,MAAO,CAAE1B,cAAaL,iBAAgBG,WAAUD,cAAaI,e,UC7BjE,EAAOiI,OAASA,EAChB,EAAOC,UAAY,kBAEJ,gB,kCCRf","file":"js/replay.0082b0be.js","sourcesContent":["export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/index.js??ref--0-1!./Replay.vue?vue&type=style&index=0&id=618b57e4&scoped=true&lang=css\"","<template>\n  <div class=\"task\">\n    <transition name=\"slidedown\">\n      <DecisionNode v-if=\"isDecisionNode\" :storeObject=\"replayStore\" />\n    </transition>\n    <transition name=\"slidedown\">\n      <Canvas v-if=\"!isDecisionNode && isLoaded\" :key=\"currentNode\" :storeObject=\"replayStore\" />\n    </transition>\n    <ReplayOverlay :replayStore=\"replayStore\" :taskStore=\"taskStore\" />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { ref, computed } from \"vue\";\nimport { useRoute } from \"vue-router\";\nimport Canvas from \"@/components/Canvas.vue\";\nimport stores from \"@/helpers/TaskGraphUtility\";\nimport DecisionNode from \"@/components/DecisionNode.vue\";\nimport ReplayOverlay from \"@/components/ReplayOverlay.vue\";\n\nexport default {\n  name: \"Replay\",\n  components: {\n    Canvas,\n    DecisionNode,\n    ReplayOverlay,\n  },\n  setup() {\n    const taskStore = stores.taskStore;\n    const replayStore = stores.replayStore;\n    const { store, getProperty, setProperty } = replayStore;\n\n    const route = useRoute();\n    if (typeof route.params.id === \"string\") {\n      store.dispatch(\"fetchReplayGraph\", { id: route.params.id });\n    }\n\n    const currentNode = computed(() => getProperty(\"currentNode\"));\n    const isDecisionNode = computed(() => {\n      const edges = getProperty(`edges__${currentNode.value}`);\n      if (edges) return edges.length > 1;\n      return false;\n    });\n\n    const isLoaded = computed(() => getProperty(`currentNode`) !== null);\n\n    return { currentNode, isDecisionNode, isLoaded, replayStore, taskStore };\n  },\n};\n</script>\n\n<style scoped>\n.slidedown-enter-active,\n.slidedown-leave-active {\n  transition: max-height 0.3s ease-in-out;\n}\n\n.slidedown-enter-to,\n.slidedown-leave-from {\n  overflow: hidden;\n  max-height: 100vh;\n}\n\n.slidedown-enter-from,\n.slidedown-leave-to {\n  overflow: hidden;\n  max-height: 0;\n}\n</style>\n","<template>\n  <div class=\"replayOverlay\">\n    <img class=\"fakeCursor\" src=\"/img/fake_cursor.png\" />\n    <div class=\"replay\" @mouseenter=\"fadeControlsIn\" @mouseleave=\"fadeControlsOut\">\n      <div class=\"progressBar\" @click=\"jumpHandler\">\n        <div class=\"progress\"></div>\n        <div :class=\"`marker__${i} marker`\" :style=\"placeMarker(i)\" v-for=\"(marker, i) in replayGraph.steps\" :key=\"marker.timestamp\">|</div>\n      </div>\n      <div class=\"controlElements\">\n        <Button class=\"playButton\" :callback=\"startStopHandler\" :label=\"'&#9658;'\" />\n        <Button class=\"enterButton\" :callback=\"enterTask\" :label=\"'&#128498;'\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, watch, onMounted } from \"vue\";\nimport Button from \"@/components/Button.vue\";\nimport { useRouter } from \"vue-router\";\nexport default {\n  name: \"ReplayOverlay\",\n  props: {\n    replayStore: Object,\n    taskStore: Object,\n  },\n  components: { Button },\n  setup(props) {\n    const router = useRouter();\n\n    const { store, getProperty, setProperty } = props.replayStore;\n    const replayGraph = computed(() => {\n      const replay = getProperty(\"taskReplay\");\n      if (!replay) return {};\n      return replay;\n    });\n\n    const barSize = window.innerWidth * 0.6 * 0.95;\n    const barOffset = window.innerWidth * 0.215;\n\n    const calcDuration = (replayGraph) => {\n      const times = { start: new Date().getTime(), duration: 0, end: 0 };\n      Object.values(replayGraph).forEach((events: Array<any>) => {\n        if (!events.length) return;\n        const firstEvent = events[0].timestamp;\n        const lastEvent = events[events.length - 1].timestamp;\n        if (firstEvent < times.start) times.start = firstEvent;\n        if (lastEvent > times.end) times.end = lastEvent;\n      });\n\n      times.duration = times.end - times.start;\n      return times;\n    };\n\n    const segmentMouse = (replayGraph, start) => {\n      const { mouse } = replayGraph;\n      let previous = start;\n      let segment = [];\n      const segments = mouse.reduce((segments, event) => {\n        const { timestamp } = event;\n        if (timestamp - previous <= 50) {\n          segment.push(event);\n        } else {\n          segments[previous] = segment;\n          segment = [event];\n        }\n        previous += 50;\n        return segments;\n      }, {});\n      return segments;\n    };\n    let start, duration, end;\n    let current = start;\n    let mouseSegments = {};\n    watch(replayGraph, (newReplayGraph) => {\n      setProperty({ path: \"currentTask\", value: newReplayGraph.steps[0].value });\n\n      ({ start, duration, end } = calcDuration(newReplayGraph));\n      mouseSegments = segmentMouse(newReplayGraph, start);\n      current = start;\n    });\n\n    const placeMarker = (i) => {\n      const timestamp = replayGraph.value.steps[i].timestamp;\n      const difference = timestamp - start;\n      const percentage = difference / duration;\n      const position = percentage * barSize;\n      return { left: `${position}px` };\n    };\n\n    const applyMouse = (timestamp: number, jump: boolean = false) => {\n      const cursor: HTMLElement = document.querySelector(\".fakeCursor\");\n      const { mouse } = replayGraph.value;\n      if (jump) {\n        const movements = mouse.filter((event) => event.timestamp < timestamp);\n        if (movements.length) {\n          const { x, y } = movements[movements.length - 1];\n          cursor.style.transform = `translate(${x}px, ${y}px)`;\n        }\n        return;\n      }\n      if (timestamp in mouseSegments) {\n        mouseSegments[timestamp].forEach((event) => {\n          const { x, y } = event;\n          cursor.style.transform = `translate(${x}px, ${y}px)`;\n        });\n      }\n    };\n\n    // baseCoordinates are set when the play button is first clicked\n    let baseCoordinates = { x: 5000, y: 5000 };\n    const applyPanning = (timestamp) => {\n      if (baseCoordinates) {\n        const { x, y } = baseCoordinates;\n\n        const events = replayGraph.value.panning.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n\n        events.forEach((event) => {\n          const relativeX = Math.abs(x) - Math.abs(event.x);\n          const relativeY = Math.abs(y) - Math.abs(event.y);\n          window.panzoom.pan(relativeX, relativeY, { relative: true, animate: true });\n          baseCoordinates = window.panzoom.getPan();\n        });\n      }\n    };\n\n    const applyZooming = (timestamp) => {\n      const events = replayGraph.value.zooming.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n      events.forEach((zoomEvent) => {\n        let { scale, x, y } = zoomEvent;\n        window.panzoom.zoomToPoint(scale, { clientX: x, clientY: y }, { animate: true });\n      });\n    };\n\n    const applyEvents = (timestamp: number) => {\n      let events = [];\n      if (timestamp < current) {\n        store.dispatch(\"clearState\");\n        events = replayGraph.value.steps.filter((event) => event.timestamp < timestamp);\n      } else {\n        events = replayGraph.value.steps.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n      }\n      events.forEach((event) => {\n        const { path, value } = event;\n        setProperty({ path, value });\n      });\n    };\n\n    const convertPxToTimestamp = (px: number): number => {\n      const timestamp = (px / barSize) * duration + start;\n      return timestamp;\n    };\n\n    const jumpHandler = (event) => {\n      const progressBar = event.currentTarget;\n      const progress = progressBar.firstChild;\n      const clickPosition = event.pageX - barOffset;\n      progress.style.width = `${clickPosition}px`;\n      const timestamp = convertPxToTimestamp(clickPosition);\n      current = timestamp;\n      mouseSegments = segmentMouse(replayGraph.value, timestamp);\n      applyEvents(timestamp);\n      applyMouse(timestamp, true);\n      applyPanning(timestamp);\n      applyZooming(timestamp);\n    };\n\n    let progressInterval;\n    let isPlaying = false;\n    const startStopHandler = (event) => {\n      const playButton = event.currentTarget;\n      if (isPlaying) {\n        clearInterval(progressInterval);\n        isPlaying = !isPlaying;\n        playButton.innerHTML = \"&#9658;\";\n        return;\n      }\n      playButton.innerHTML = \"&#10074; &#10074;\";\n      isPlaying = !isPlaying;\n      const increment = 50;\n      let timestamp = current;\n\n      const pxPerIncrement = (increment * barSize) / duration;\n      const progress: HTMLElement = document.querySelector(\".progress\");\n\n      progressInterval = setInterval(() => {\n        const currentWidth = progress.offsetWidth;\n        const newWidth = currentWidth + pxPerIncrement;\n        if (newWidth > barSize) {\n          clearInterval(progressInterval);\n          isPlaying = !isPlaying;\n          playButton.innerHTML = \"&#9658;\";\n        }\n        progress.style.width = `${newWidth}px`;\n        timestamp += increment;\n        applyEvents(timestamp);\n        applyMouse(timestamp);\n        applyPanning(timestamp);\n        // applyZooming(timestamp);\n        current = timestamp;\n\n        if (!baseCoordinates && window.panzoom) {\n          baseCoordinates = window.panzoom.getPan();\n        }\n      }, increment);\n    };\n\n    const enterTask = () => {\n      const task = getProperty(\"currentTask\");\n      const properties = [\n        \"currentTask\",\n        \"layoutSize\",\n        \"currentNode\",\n        \"previousNode\",\n        \"rootNode\",\n        \"topology\",\n        \"edges\",\n        \"nodes\",\n        \"taskData\",\n        \"taskReplay\",\n      ];\n\n      properties.forEach((property) => {\n        let propertyValue = getProperty(property);\n        if (property === \"taskReplay\") {\n          const timeCorrectedReplay = Object.entries(propertyValue).reduce(\n            (timeCorrectedReplay, [eventType, eventValues]: [string, Array<any>]) => {\n              if (eventType === \"meta\") return timeCorrectedReplay;\n              const timeCorrectedValues = eventValues.map((event) => {\n                const current = new Date().getTime();\n                const offset = current - event.timestamp;\n                event.timestamp = current - offset;\n                return event;\n              });\n              timeCorrectedReplay[eventType] = timeCorrectedValues;\n              return timeCorrectedReplay;\n            },\n            {}\n          );\n          propertyValue = timeCorrectedReplay;\n        }\n        props.taskStore.setProperty({ path: property, value: propertyValue });\n        props.taskStore.store.dispatch(\"restoredFromReplay\");\n      });\n\n      router.push({ name: \"Task\", params: { task } });\n    };\n\n    let fade;\n    const fadeControlsIn = (event) => {\n      clearTimeout(fade);\n      const controls: HTMLElement = event.target;\n      controls.style.opacity = \"1\";\n    };\n    const fadeControlsOut = (event) => {\n      const controls: HTMLElement = event.target;\n      fade = setTimeout(() => {\n        controls.style.opacity = \"0.3\";\n      }, 3000);\n    };\n\n    return { replayGraph, jumpHandler, startStopHandler, placeMarker, enterTask, fadeControlsIn, fadeControlsOut };\n  },\n};\n</script>\n\n<style scoped>\n.replayOverlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100vh;\n  width: 100vw;\n  z-index: 4;\n}\n\n.replay {\n  position: fixed;\n  display: flex;\n  flex-direction: column;\n  left: 20vw;\n  bottom: 5vh;\n  height: 15vh;\n  width: 60vw;\n  align-items: center;\n  justify-content: space-around;\n  z-index: 3;\n}\n\n.progressBar {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  background: #b1b2b4;\n  height: 20px;\n  width: 95%;\n  border-radius: 10px;\n  border: 1px solid #f1ad2d;\n  box-shadow: 2px 3px 9px 0px rgba(0, 0, 0, 1);\n  cursor: pointer;\n}\n.progress {\n  position: absolute;\n  background: #57636b;\n  height: 20px;\n  width: 0;\n  z-index: 1;\n}\n.marker {\n  position: absolute;\n  color: black;\n  width: 1.5px;\n}\n\n.controlElements {\n  display: flex;\n  width: 15vw;\n  height: 8vh;\n  justify-content: space-around;\n  transition: opacity 2s linear;\n  opacity: 1;\n}\n\n.fakeCursor {\n  display: none;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 40px;\n  height: 40px;\n  transition: 0.05s;\n}\n</style>\n","\nimport { computed, watch, onMounted } from \"vue\";\nimport Button from \"@/components/Button.vue\";\nimport { useRouter } from \"vue-router\";\nexport default {\n  name: \"ReplayOverlay\",\n  props: {\n    replayStore: Object,\n    taskStore: Object,\n  },\n  components: { Button },\n  setup(props) {\n    const router = useRouter();\n\n    const { store, getProperty, setProperty } = props.replayStore;\n    const replayGraph = computed(() => {\n      const replay = getProperty(\"taskReplay\");\n      if (!replay) return {};\n      return replay;\n    });\n\n    const barSize = window.innerWidth * 0.6 * 0.95;\n    const barOffset = window.innerWidth * 0.215;\n\n    const calcDuration = (replayGraph) => {\n      const times = { start: new Date().getTime(), duration: 0, end: 0 };\n      Object.values(replayGraph).forEach((events: Array<any>) => {\n        if (!events.length) return;\n        const firstEvent = events[0].timestamp;\n        const lastEvent = events[events.length - 1].timestamp;\n        if (firstEvent < times.start) times.start = firstEvent;\n        if (lastEvent > times.end) times.end = lastEvent;\n      });\n\n      times.duration = times.end - times.start;\n      return times;\n    };\n\n    const segmentMouse = (replayGraph, start) => {\n      const { mouse } = replayGraph;\n      let previous = start;\n      let segment = [];\n      const segments = mouse.reduce((segments, event) => {\n        const { timestamp } = event;\n        if (timestamp - previous <= 50) {\n          segment.push(event);\n        } else {\n          segments[previous] = segment;\n          segment = [event];\n        }\n        previous += 50;\n        return segments;\n      }, {});\n      return segments;\n    };\n    let start, duration, end;\n    let current = start;\n    let mouseSegments = {};\n    watch(replayGraph, (newReplayGraph) => {\n      setProperty({ path: \"currentTask\", value: newReplayGraph.steps[0].value });\n\n      ({ start, duration, end } = calcDuration(newReplayGraph));\n      mouseSegments = segmentMouse(newReplayGraph, start);\n      current = start;\n    });\n\n    const placeMarker = (i) => {\n      const timestamp = replayGraph.value.steps[i].timestamp;\n      const difference = timestamp - start;\n      const percentage = difference / duration;\n      const position = percentage * barSize;\n      return { left: `${position}px` };\n    };\n\n    const applyMouse = (timestamp: number, jump: boolean = false) => {\n      const cursor: HTMLElement = document.querySelector(\".fakeCursor\");\n      const { mouse } = replayGraph.value;\n      if (jump) {\n        const movements = mouse.filter((event) => event.timestamp < timestamp);\n        if (movements.length) {\n          const { x, y } = movements[movements.length - 1];\n          cursor.style.transform = `translate(${x}px, ${y}px)`;\n        }\n        return;\n      }\n      if (timestamp in mouseSegments) {\n        mouseSegments[timestamp].forEach((event) => {\n          const { x, y } = event;\n          cursor.style.transform = `translate(${x}px, ${y}px)`;\n        });\n      }\n    };\n\n    // baseCoordinates are set when the play button is first clicked\n    let baseCoordinates = { x: 5000, y: 5000 };\n    const applyPanning = (timestamp) => {\n      if (baseCoordinates) {\n        const { x, y } = baseCoordinates;\n\n        const events = replayGraph.value.panning.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n\n        events.forEach((event) => {\n          const relativeX = Math.abs(x) - Math.abs(event.x);\n          const relativeY = Math.abs(y) - Math.abs(event.y);\n          window.panzoom.pan(relativeX, relativeY, { relative: true, animate: true });\n          baseCoordinates = window.panzoom.getPan();\n        });\n      }\n    };\n\n    const applyZooming = (timestamp) => {\n      const events = replayGraph.value.zooming.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n      events.forEach((zoomEvent) => {\n        let { scale, x, y } = zoomEvent;\n        window.panzoom.zoomToPoint(scale, { clientX: x, clientY: y }, { animate: true });\n      });\n    };\n\n    const applyEvents = (timestamp: number) => {\n      let events = [];\n      if (timestamp < current) {\n        store.dispatch(\"clearState\");\n        events = replayGraph.value.steps.filter((event) => event.timestamp < timestamp);\n      } else {\n        events = replayGraph.value.steps.filter((event) => event.timestamp < timestamp && event.timestamp > current);\n      }\n      events.forEach((event) => {\n        const { path, value } = event;\n        setProperty({ path, value });\n      });\n    };\n\n    const convertPxToTimestamp = (px: number): number => {\n      const timestamp = (px / barSize) * duration + start;\n      return timestamp;\n    };\n\n    const jumpHandler = (event) => {\n      const progressBar = event.currentTarget;\n      const progress = progressBar.firstChild;\n      const clickPosition = event.pageX - barOffset;\n      progress.style.width = `${clickPosition}px`;\n      const timestamp = convertPxToTimestamp(clickPosition);\n      current = timestamp;\n      mouseSegments = segmentMouse(replayGraph.value, timestamp);\n      applyEvents(timestamp);\n      applyMouse(timestamp, true);\n      applyPanning(timestamp);\n      applyZooming(timestamp);\n    };\n\n    let progressInterval;\n    let isPlaying = false;\n    const startStopHandler = (event) => {\n      const playButton = event.currentTarget;\n      if (isPlaying) {\n        clearInterval(progressInterval);\n        isPlaying = !isPlaying;\n        playButton.innerHTML = \"&#9658;\";\n        return;\n      }\n      playButton.innerHTML = \"&#10074; &#10074;\";\n      isPlaying = !isPlaying;\n      const increment = 50;\n      let timestamp = current;\n\n      const pxPerIncrement = (increment * barSize) / duration;\n      const progress: HTMLElement = document.querySelector(\".progress\");\n\n      progressInterval = setInterval(() => {\n        const currentWidth = progress.offsetWidth;\n        const newWidth = currentWidth + pxPerIncrement;\n        if (newWidth > barSize) {\n          clearInterval(progressInterval);\n          isPlaying = !isPlaying;\n          playButton.innerHTML = \"&#9658;\";\n        }\n        progress.style.width = `${newWidth}px`;\n        timestamp += increment;\n        applyEvents(timestamp);\n        applyMouse(timestamp);\n        applyPanning(timestamp);\n        // applyZooming(timestamp);\n        current = timestamp;\n\n        if (!baseCoordinates && window.panzoom) {\n          baseCoordinates = window.panzoom.getPan();\n        }\n      }, increment);\n    };\n\n    const enterTask = () => {\n      const task = getProperty(\"currentTask\");\n      const properties = [\n        \"currentTask\",\n        \"layoutSize\",\n        \"currentNode\",\n        \"previousNode\",\n        \"rootNode\",\n        \"topology\",\n        \"edges\",\n        \"nodes\",\n        \"taskData\",\n        \"taskReplay\",\n      ];\n\n      properties.forEach((property) => {\n        let propertyValue = getProperty(property);\n        if (property === \"taskReplay\") {\n          const timeCorrectedReplay = Object.entries(propertyValue).reduce(\n            (timeCorrectedReplay, [eventType, eventValues]: [string, Array<any>]) => {\n              if (eventType === \"meta\") return timeCorrectedReplay;\n              const timeCorrectedValues = eventValues.map((event) => {\n                const current = new Date().getTime();\n                const offset = current - event.timestamp;\n                event.timestamp = current - offset;\n                return event;\n              });\n              timeCorrectedReplay[eventType] = timeCorrectedValues;\n              return timeCorrectedReplay;\n            },\n            {}\n          );\n          propertyValue = timeCorrectedReplay;\n        }\n        props.taskStore.setProperty({ path: property, value: propertyValue });\n        props.taskStore.store.dispatch(\"restoredFromReplay\");\n      });\n\n      router.push({ name: \"Task\", params: { task } });\n    };\n\n    let fade;\n    const fadeControlsIn = (event) => {\n      clearTimeout(fade);\n      const controls: HTMLElement = event.target;\n      controls.style.opacity = \"1\";\n    };\n    const fadeControlsOut = (event) => {\n      const controls: HTMLElement = event.target;\n      fade = setTimeout(() => {\n        controls.style.opacity = \"0.3\";\n      }, 3000);\n    };\n\n    return { replayGraph, jumpHandler, startStopHandler, placeMarker, enterTask, fadeControlsIn, fadeControlsOut };\n  },\n};\n","import { render } from \"./ReplayOverlay.vue?vue&type=template&id=49bb9895&scoped=true\"\nimport script from \"./ReplayOverlay.vue?vue&type=script&lang=ts\"\nexport * from \"./ReplayOverlay.vue?vue&type=script&lang=ts\"\n\nimport \"./ReplayOverlay.vue?vue&type=style&index=0&id=49bb9895&scoped=true&lang=css\"\nscript.render = render\nscript.__scopeId = \"data-v-49bb9895\"\n\nexport default script","\nimport { ref, computed } from \"vue\";\nimport { useRoute } from \"vue-router\";\nimport Canvas from \"@/components/Canvas.vue\";\nimport stores from \"@/helpers/TaskGraphUtility\";\nimport DecisionNode from \"@/components/DecisionNode.vue\";\nimport ReplayOverlay from \"@/components/ReplayOverlay.vue\";\n\nexport default {\n  name: \"Replay\",\n  components: {\n    Canvas,\n    DecisionNode,\n    ReplayOverlay,\n  },\n  setup() {\n    const taskStore = stores.taskStore;\n    const replayStore = stores.replayStore;\n    const { store, getProperty, setProperty } = replayStore;\n\n    const route = useRoute();\n    if (typeof route.params.id === \"string\") {\n      store.dispatch(\"fetchReplayGraph\", { id: route.params.id });\n    }\n\n    const currentNode = computed(() => getProperty(\"currentNode\"));\n    const isDecisionNode = computed(() => {\n      const edges = getProperty(`edges__${currentNode.value}`);\n      if (edges) return edges.length > 1;\n      return false;\n    });\n\n    const isLoaded = computed(() => getProperty(`currentNode`) !== null);\n\n    return { currentNode, isDecisionNode, isLoaded, replayStore, taskStore };\n  },\n};\n","import { render } from \"./Replay.vue?vue&type=template&id=618b57e4&scoped=true\"\nimport script from \"./Replay.vue?vue&type=script&lang=ts\"\nexport * from \"./Replay.vue?vue&type=script&lang=ts\"\n\nimport \"./Replay.vue?vue&type=style&index=0&id=618b57e4&scoped=true&lang=css\"\nscript.render = render\nscript.__scopeId = \"data-v-618b57e4\"\n\nexport default script","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/@vue/cli-service/node_modules/vue-loader-v16/dist/index.js??ref--0-1!./ReplayOverlay.vue?vue&type=style&index=0&id=49bb9895&scoped=true&lang=css\""],"sourceRoot":""}